# https://www.javadrive.jp/python/
# 【条件分岐】

# if文を使った条件分岐
# Pythonにおけるインデントを使ったブロックの定義
# どのようなオブジェクトが真(True)や偽(False)と評価されるのか
# 比較演算子の使い方
# 論理演算子の使い方
# オブジェクトが同一かどうかの比較する(== 演算子と is 演算子の違い)



# 【if文を使った条件分岐】
# if文を使った条件分岐

# Python で条件分岐を行うには if 文を使います。ここでは if 文を使った条件分岐の方法について解説します。

# 目次

# １、if文の基本的な使い方
# ２、条件式が偽の時の処理(if...else)
# ３、複数の条件式を使った条件分岐(if...elif...else)

# if文の基本的な使い方
# if 文は指定した条件式が真の時にだけ処理を実行します。基本的な書式は次の通りです。

# if 条件式:
#     条件式が真の時に実行する文
# 条件式が真となった場合、その後に記述されたブロックの中の文を順に実行します。複数の文を実行させたい場合にはブロック内に記述してください。

# if 条件式:
#     条件式が真の時に実行する文1
#     条件式が真の時に実行する文2
#     条件式が真の時に実行する文3
# ※ Python ではブロックをインデントを使って定義します。詳しくは「Pythonにおけるインデントを使ったブロックの定義」を参照されてください。

# 条件式では比較演算子や論理演算子を使って条件を記述します。次の例では変数 old に代入されている値が 20 よりも小さい場合にブロック内の処理を実行します。

# old = 18

# if old < 20:
#     print("20歳未満の方はご利用できません")
# 変数 old には 18 という数値が代入されているので、 if 文に記述された条件式は真となり、その後に記述されたブロック内の文が実行されます。

# サンプルプログラム
# それでは簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample1-1.py という名前で保存します。

# old = 18
# print("年齢は" + str(old) + "です。")

# if old < 20:
#     print("20歳未満の方はご利用できません。")
#     print("またのご利用をお待ちしています。")

# print("ありがとうございました。\n")

# old = 24
# print("年齢は" + str(old) + "です。")

# if old < 20:
#     print("20歳未満の方はご利用できません。")
#     print("またのご利用をお待ちしています。")

# print("ありがとうございました。")
# if文の基本的な使い方(1)

# その後で、次のように実行してください。

# python sample1-1.py

# if文の基本的な使い方(2)

# 変数 old に 数値を代入したあとで if 文を実行しています。最初は if 文の条件式が真となったため、その後のブロックに記述された文が実行されました。次のときは if 文の条件式が偽となったため if 文のブロック内の文は実行されずに次の処理へ移りました。

# 条件式が偽の時の処理(if...else)
# if 文では指定した条件式が真の時に実行する処理をブロックの中に記述しますが、あわせて条件式が偽だった場合に実行する処理を記述することもできます。次の書式を使用します。

# if 条件式:
#     条件式が真の時に実行する文
#     ...
# else:
#     条件式が偽の時に実行する文
#     ...
# if 文の条件式が偽だった場合に実行する文を else: のあとのブロック内に記述します。条件式は必ず真か偽のどちらかとなりますので、真の時のブロックか偽の時のブロックかどちらか必ず一つのブロック内の文を実行することになります。

# サンプルプログラム
# それでは簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample1-2.py という名前で保存します。

# old = 18
# print("年齢は" + str(old) + "です。")

# if old < 20:
#     print("20歳未満の方はご利用できません。")
#     print("またのご利用をお待ちしています。")
# else:
#     print("ご利用ありがとうございます。開始ボタンを押してください。")

# print("\n")

# old = 24
# print("年齢は" + str(old) + "です。")

# if old < 20:
#     print("20歳未満の方はご利用できません。")
#     print("またのご利用をお待ちしています。")
# else:
#     print("ご利用ありがとうございます。開始ボタンを押してください。")
# 条件式が偽の時の処理(if...else)(1)

# その後で、次のように実行してください。

# python sample1-2.py

# 条件式が偽の時の処理(if...else)(2)

# 変数 old に 数値を代入したあとで if 文を実行しています。最初は if 文の条件式が真となったため、その後のブロックに記述された文が実行されました。次のときは if 文の条件式が偽となったため else の後のブロックに記述された文が実行されました。

# 複数の条件式を使った条件分岐(if...elif...else)
# if 文では単独の条件式だけではなく複数の条件式を使った条件分岐を記述することもできます。次の書式を使用します。

# if 条件式1:
#     条件式1が真の時に実行する文
#     ...
# elif 条件式2:
#     条件式1が偽で条件式2が真の時に実行する文
#     ...
# elif 条件式3:
#     条件式1及び条件式2が偽で条件式3が真の時に実行する文
#     ...
# else:
#     すべての条件式が偽のときに実行する文
#     ...
# 評価は上から順に行われます。最初に条件式 1 を評価し、真だった場合には次のブロック内の文を実行して if 文の次の処理へ移ります。条件式 1 が偽だった場合、次の条件式 2 を評価して、真だった場合は次のブロック内の文を実行して if 文の次の処理へ移ります。すべての条件式で同じことを繰り返し、最後にすべての条件式が偽だった場合に次のブロック内の文を実行します。

# elif は必要な数だけ記述することができます。また else の部分は不要であれば削除して構いません。

# 複数の条件式が記述されていますが、上から順に評価していきいずれかの条件式で真になった場合はその後のブロック内の文を実行し if 文の次へ処理が移ります。真となった条件式以降に記述されている条件式は評価されない点に注意してください。

# この書式は次のように記述した場合と同じです。

# if 条件式1:
#     条件式1が真の時に実行する文
#     ...
# else:
#     if 条件式2:
#         条件式1が偽で条件式2が真の時に実行する文
#         ...
#     else:
#         if 条件式3:
#             条件式1及び条件式2が偽で条件式3が真の時に実行する文
#             ...
#         else:
#             すべての条件式が偽のときに実行する文
#             ...
# ※ 他のプログラミング言語で使われる elseif ではなく elif である点に注意してください。

# サンプルプログラム
# それでは簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample1-3.py という名前で保存します。

# postcode = "125-0062"
# print("郵便番号は " + postcode + " です。")

# if postcode == "140-0015":
#     address = "東京都品川区西大井"
# elif postcode == "102-0072":
#     address = "東京都千代田区飯田橋"
# elif postcode == "125-0062":
#     address = "東京都葛飾区青戸"
# else:
#     address = "不明"

# print("住所は " + address + " です。")

# print("¥n")

# postcode = "102-0072"
# print("郵便番号は " + postcode + " です。")

# if postcode == "140-0015":
#     address = "東京都品川区西大井"
# elif postcode == "102-0072":
#     address = "東京都千代田区飯田橋"
# elif postcode == "125-0062":
#     address = "東京都葛飾区青戸"
# else:
#     address = "不明"

# print("住所は " + address + " です。")
# その後で、次のように実行してください。

# python sample1-3.py

# 複数の条件式を使った条件分岐(if...elif...else)(1)

# 変数 postcode に代入されている値を複数の条件式で評価していき、真となったあとのブロック内の文を実行しています。

# -- --

# if 文を使った条件分岐を行う方法について解説しました。



# 【Pythonにおけるインデントを使ったブロックの定義】
# Pythonにおけるインデントを使ったブロックの定義

# if 文や for 文では条件式を設定し条件式が真の場合に複数の文を実行させることができます。この時、どこからどこまでの文を実行するのかを示すのがブロックです。他のプログラミング言語ではブロックを { から } までのように定義している場合が多いですが、 Python ではインデントを使ってブロックを表現します。ここでは Python におけるインデントを使ったブロックの定義方法について解説します。

# 目次

# インデントを使ってブロックを定義する
# インデントの数はいくつにするべきか
# インデントを使ってブロックを定義する

# if 文や for 文など内部に別の文を持つ文は複合文と呼ばれます。 while 文や try 文の他に関数の定義やクラスの定義などといったものも複合文です。 if 文では条件式が真の場合に複数の文が実行されますが、どこからどこまでの文を実行するのかを示すのに使われるのがブロックです。

# 他のプログラミング言語である Java や PHP では { から } までがブロックとなります。

# if (条件式) {
#     ブロック内の処理1
#     ブロック内の処理2
# }
# プログラミング言語の Ruby では then から end までがブロックとなります。

# if 条件式 then
#     ブロック内の処理1
#     ブロック内の処理2
# end
# それに対して Python では特別な文字を使わずに同じインデントがされている文を同じブロックとして扱います。(インデントとは字下げのことです)。

# if 条件式:
#     ブロック内の処理1
#     ブロック内の処理2
# 同じ位置にインデントされている文が同じブロックとして扱われますので、インデントの数がずれていると別のブロックとみなされます。新しいブロックが出てくるべきではないところでインデントが異なる文を書いてしまうとエラーとなってしまいます。

# if 条件式:
#     ブロック内の処理1
#     ブロック内の処理2
#       ブロック内の処理3
# if 文のブロックの中にさらに if 文がある場合などはインデントをさらにさげて記述します。

# if 条件式:
#     ブロック内の処理1
#     ブロック内の処理2
#     if 条件式:
#         ブロック内の処理1
#         ブロック内の処理2
#         if 条件式:
#             ブロック内の処理1
#             ブロック内の処理2
#     ブロック内の処理3
#     ブロック内の処理4
#     if 条件式:
#         ブロック内の処理1
#         ブロック内の処理2
# 括弧などを使用せずにインデントだけでブロックを表現するので無駄なコードが含まれずインデントが必ず綺麗に揃うことになります。

# インデントの数はいくつにするべきか
# インデントはタブまたはスペースで行いますが、スペース何文字分というルールは決まっていませんので例えばスペース 2 文字なら 2 文字で統一して利用されれば問題はないかと思います。迷われた場合は Python のコードを記述する上でスタイルガイドとして PEP: 8 という文書が公開されています。

# ・PEP 8 -- Style Guide for Python Code

# ・PEP8 日本語版

# PEP8 日本語版

# ここでは 1 レベルのインデント毎にスペースを 4 つ使用することを推奨しています。このサイトでもインデントは空白 4 つで統一するようにしています。

# -- --

# Python におけるインデントを使ったブロックの定義方法について解説しました。



# 【どのようなオブジェクトが真(True)や偽(False)と評価されるのか】

# if 文や for 文などの条件式でオブジェクトが記述された場合に、どのようなオブジェクトが真(True)でどのようなオブジェクトが偽(False)と判定されるのかについて解説します。

# 目次

# 真や偽と判定される基準

# 真や偽と判定される基準
# if 文などの条件式で比較演算子や論理演算子を使った式を記述した場合、結果としてブール値の True または False を返します。(ブール値については「ブール値(True、False)の使い方」を参照されてください)。その結果に従って続くブロック内の文を実行するのかが決まります。

# このような条件式を記述するところでオブジェクトをそのものを記述した場合に真( True )と判定されるのか偽( False )と判定されるのかについては次のルールに従います。(以下では真か偽かの判定に組み込み関数の bool 関数を使用しています。 bool 関数については「bool関数の使い方(オブジェクトが真か偽か判定する)」を参照されてください)。

# 組み込み定数の中でブール値である True は真、 False は偽と判定されます。また None は偽、 NotImplemented は真と判定されます。

# >>> bool(True)
# True
# >>> bool(False)
# False
# >>> bool(None)
# False
# >>> bool(NotImplemented)
# True
# >>>
# 数値型の値は 0 、 0.0 , 0j は偽、それ以外の値は真と判定されます。

# >>> bool(0)
# False
# >>> bool(5)
# True
# >>> bool(0.0)
# False
# >>> bool(0.1)
# True
# >>> bool(0j)
# False
# >>>
# 文字列型は空文字"" は偽、それ以外は真と判定されます。

# >>> bool("")
# False
# >>> bool("Hello")
# True
# >>>
# 空のタプル()、空のリスト[]、空のディクショナリ{}は偽、それ以外は真と判定されます。

# >>> bool(())
# False
# >>> bool(("Blue","Red"))
# True
# >>> bool([])
# False
# >>> bool(["Apple", "Orange"])
# True
# >>> bool({})
# False
# >>> bool({"A":"Apple","O":"Orage"})
# True
# >>>
# 主なオブジェクトについて真と判定されるものと偽と判定されるものについて確認しました。

# サンプルプログラム
# それでは簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample3-1.py という名前で保存します。

# name = ""
# if name:
#     print("名前は" + name + "です")
# else:
#     print("名前は未登録です")

# print("¥n")

# name = "Yamada"
# if name:
#     print("名前は" + name + "です")
# else:
#     print("名前は未登録です")
# 真や偽と判定される基準(1)

# その後で、次のように実行してください。

# python sample3-1.py

# 真や偽と判定される基準(2)

# 変数 name に最初は空文字を代入し、次に空文字ではない文字列を代入して if 文の条件式でそれぞれ評価しました。空文字は偽、空文字ではない文字列は真と判定されました。

# -- --

# 条件式でオブジェクトが記述された場合に、どのようなオブジェクトが真(True)でどのようなオブジェクトが偽(False)と判定されるのかについて解説しました。



# 【比較演算子の使い方】
# 比較演算子の使い方

# 2 つの値が等しいかどうか、どちらかの値がもう片方の値よりも大きいかどうかなど 2 つの値を比較する時に使用するのが比較演算子です。比較演算子は結果として True または False を返します。ここでは比較演算子の使い方について解説します。

# 目次

# 比較演算子の一覧
# 等しいかどうかの比較
# 大きいか小さいかの比較
# 要素が含まれるかどうか
# 異なるデータ型のオブジェクトの比較について

# 比較演算子の一覧
# Python で用意されている比較演算子の一覧です。

# x == y       x と y が等しい
# X != y       x と y が等しくない
# x > y        x は y よりも大きい
# x < y        x は y よりも小さい
# x >= y       x は y と等しいか大きい
# x <= y       x は y と等しいか小さい
# x in y       x という要素 が y に存在する
# x not in y   x という要素 が y に存在しない
# 左辺と右辺のオブジェクトが等しいかどうか、また大きいか小さいかなどを比較します。結果としてブール値の True または False を返します。

# 等しいかどうかの比較
# 等しいかどうかの比較には == 演算子または != 演算子を使います。 == 演算子は左辺と右辺が等しければ True を返します。逆に != 演算子は左辺と右辺が異なる場合に True を返します。

# 数値の比較
# 数値を比較する場合は、整数と整数だけではなく整数と浮動小数点数が等しいかどうかを比較することができます。

# >>> bool(10 == 10)
# True
# >>> bool(10 == 8)
# False
# >>> bool(10 == 10.0)
# True
# >>>
# 整数の 10 と浮動小数点数の 10.0 を比較した場合、数値として等しい場合には True となります。

# 文字列の比較
# 文字列を比較する場合は、文字列の値が等しいかどうか比較します。大文字と小文字は区別されます。

# >>> bool("Hello" == "Hello")
# True
# >>> bool("Hello" == "Hey")
# False
# >>> bool("Hello" == "hello")
# False
# >>>
# タプルやリストの比較
# タプルやリストの場合、1つ1つの要素が完全に一致している場合に True となります。

# >>> bool(["Red", "Blue"] == ["Red", "Blue"])
# True
# >>> bool(["Red", "Blue", "Yello"] == ["Red", "Blue"])
# False
# >>>
# 整数の 10 と浮動小数点数の 10.0 を比較した場合、数値として等しい場合には True となります。

# 大きいか小さいかの比較
# 大きいか小さいかの比較には < 演算子, > 演算子, <= 演算子, >= 演算子を使います。 < 演算子 では左辺が右辺よりも小さい場合に True となり > 演算子はその逆です。また <= 演算子では左辺が右辺よりも等しいか小さい場合に True となり >= 演算子はその逆です。

# 数値の比較
# 数値を比較する場合は、数値の大小を比較します。なお複素数は大きいか小さいかの比較は行えません。

# >>> bool(5 > 3)
# True
# >>> bool(7 < 3)
# False
# >>> bool(4 >= 4)
# True
# >>>
# 文字列の比較
# 文字列を比較する場合は文字の Unicode のコードポイントで比較します。先頭の文字で比較し同じならば次の文字と比較していきます。文字に対する Unicode のコードポイントは組み込み関数の ord 関数で確認することができます。

# >>> ord("a")
# 97
# >>> ord("b")
# 98
# >>> ord("c")
# 99
# >>> ord("A")
# 65
# >>>
# "a" のコードポイントは 97 で "b" のコードポイントは 98 です。また "A" のコードポイントは 65 です。その為、 "a" と "b" で大きいかどうかを比較した場合には "b" の方が大きくなり、 "a" と "A" で大きいかどうかを比較した場合は "a" の方が大きくなります。

# >>> bool("apple" > "bread")
# False
# >>> bool("apple" > "Apple")
# True
# >>>
# 例えば "abc" と "abcde" のような文字列の比較の場合は長い方の文字列が大きくなります。

# >>> bool("abc" < "abcde")
# True
# >>>
# タプルやリストの比較
# タプルやリストで大きいか小さいかの比較を行う場合、最初の異なる要素で比較が行われます。例えば ["red", "blue", "green"] と ["red", "blue", "white"] の比較では 1 番目と 2 番目の要素は等しいので 3 番目の要素で大きいかどうかの比較が行われます。

# >>> bool(["red", "blue", "green"] > ["red", "blue", "white"])
# False
# >>>
# 例えば ["aa", "bb"] と ["aa", "bb", "cc"] のような比較の場合は要素が多い方が大きくなります。

# >>> bool(["aa", "bb"] < ["aa", "bb", "cc"])
# True
# >>>
# 要素が含まれるかどうか
# 指定した要素が含まれるかどうかを評価するには in 演算子を使います。 in 演算子は要素が含まれる場合に True となり、 not in 演算子は要素が含まれない場合に True となります。

# 例えば "apple" が ["orange", "apple", "lemon"] リストに含まれていれば True となります。

# >>> bool("apple" in ["orange", "apple", "lemon"])
# True
# >>> bool("grape" in ["orange", "apple", "lemon"])
# False
# >>>
# "apple" はリストに含まれているため True となり "grape" はリストに含まれていないので False となります。

# 異なるデータ型のオブジェクトの比較について
# Python では異なるデータ型の比較はできる場合とできない場合があります。例えば整数と複素数の比較は等しいかどうかや大きいかどうかのどちらでも可能です。

# >>> bool (8 == 8.0)
# True
# >>> bool (14 < 9.5)
# False
# >>>
# ただ文字列と数値が等しいかどうかを比較すると常に False となります。文字列が数値の値を文字列であっても同じです。

# >>> bool (10 == "10")
# False
# >>>
# 文字列と数値で大きいかどうかを比較しようとすると TypeError エラーとなります。

# >>> bool (10 > "8")
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: '>' not supported between instances of 'int' and 'str'
# >>>
# 数値の値の文字列と数値で大きいかどうかを比較する場合は int 関数を使って文字列を数値に変換してから比較を行ってください。( int 関数については「int関数/float関数の使い方(文字列を数値に変換する)」を参照されてください)。

# >>> bool (14 > int("10"))
# True
# >>>
# -- --

# 比較演算子の一覧と使い方について解説しました。



# 【論理演算子の使い方】
# 論理演算子の使い方

# 論理演算子(またはブール演算子)は a 且つ b や a 又は b のようにブール値を組み合わせて評価する場合に使用される演算子です。ここでは論理演算子の使い方について解説します。

# 目次

# 論理演算子の一覧
# 論理和
# 論理積
# 否定

# 論理演算子の一覧
# Python で用意されている論理演算子の一覧です。

# x or y    x または y の少なくともどちらか 1 つが True なら True
#           それ以外は False
# x and y   x と y がどちらも True なら True
#           それ以外は False
# not x     x が True なら False、 x が False なら True
# 実際には True または False ではなく真か偽か判定すると True または False になる値が帰ってきます。詳しくはあとで解説します。

# 論理和
# 論理和は演算子の左辺または右辺のどちらか 1 つでも True なら True となり、両方とも False の場合だけ False となります。

# True  or True      True
# True  or False     True
# False or True      True
# False or False     False
# 具体的な次のような使い方となります。

# >>> num = 8
# >>> bool(num < 10 or num > 40)
# True
# >>>
# 変数 num に格納されている値に対して num < 10 という条件式と、 num > 40 という条件式を評価します。論理和の場合はどちらかが少なくとも 1 つが True ならば全体が True となるため今回は True となりました。

# もう少し細かい話をすると、論理和の場合 x or y という式に対して最初に x を評価します。 x が偽だった場合は y を返します。 x が真だった場合は x を返します。

# 論理積
# 論理積は演算子の左辺および右辺がどちらも True なら True となり、それ以外は False となります。

# True  and True      True
# True  and False     False
# False and True      False
# False and False     False
# 具体的な次のような使い方となります。

# >>> num = 24
# >>> bool(num > 10 and num < 40)
# True
# >>>
# 変数 num に格納されている値に対して num > 10 という条件式と、 num < 40 という条件式を評価します。論理積の場合は両方とも True ならば全体が True となるため今回は True となりました。

# もう少し細かい話をすると、論理積の場合 x and y という式に対して最初に x を評価します。 x が偽だった場合は x を返します。 x が真だった場合は y を返します。

# 否定
# 否定は演算子の左辺が True なら False となり、左辺が False なら True となります。

# not True      False
# not False     True
# 具体的な次のような使い方となります。

# >>> old = 24
# >>> bool(not old < 20)
# True
# >>>
# 変数 old に格納されている値に対して old < 20 という条件式を評価します。否定の場合は右辺が True ならば全体が False、右辺が False ならば全体が True となるため今回は True となりました。

# 否定の場合は not x という式に対して x が偽だった場合は True を返します。 x が真だった場合は False を返します。

# -- --

# 論理演算子の一覧と使い方について解説しました。



# 【オブジェクトが同一かどうかの比較する(== 演算子と is 演算子の違い)】
# オブジェクトが同一かどうかの比較する(== 演算子と is 演算子の違い)

# 数値や文字列、リストやタプルなどのオブジェクトが同じかどうかを調べるには is 演算子を使用します。ここでは is 演算子を使ってオブジェクトが同じかどうか調べる方法と、オブジェクトの値が同じかどうかを調べる == 演算子との違いを解説します。

# 目次

# is 演算子の使い方と == 演算子との違い
# mutableオブジェクトとimmutableオブジェクトでの is 演算子の結果の違い
# id関数を使ってオブジェクト固有のidを取得する
# is 演算子の使い方と == 演算子との違い

# Python では数値や文字列、リストやタプルはすべてオブジェクトです。オブジェクトが同じかどうかを調べるには is 演算子を使用します。

# x is y       x と y が同じオブジェクトの場合は True
# x not is y   x と y が別のオブジェクトの場合は True
# 同じような演算子に == 演算子がありますが、 == 演算子はオブジェクトの値が同じかどうかを判定する場合に使用します。異なるオブジェクトであっても値が同じであれば True となります。それに対して is 演算子は値が同じであってもオブジェクトが異なる場合は False となります。

# 例えば次の例をみてください。 2 つのリストを作成し、 == 演算子と is 演算子を使って調べてみます。

# >>> list1 = [1, 2, 3]
# >>> list2 = [1, 2, 3]
# >>> list1 == list2
# True
# >>> list1 is list2
# False
# >>>
# 最初に == 演算子で 2 つのリストを判定してみると True となります。リストの場合は各要素が同じデータ型で同じ値を持っている場合は True となるためです。それに対して is 演算子では False となります。値は同じでもオブジェクトはそれぞれ別々だからです。

# では次の例をみてください。最初のリストを作成したあとで、 2 つ目のリストには最初のリストを代入しています。

# >>> list1 = [1, 2, 3]
# >>> list2 = list1
# >>> list1 == list2
# True
# >>> list1 is list2
# True
# >>>
# この場合 list2 と list1 は同じリストのオブジェクトを指し示しています。その為、値を比較する == が True を返すだけでなく、オブジェクトが同じかどうかを判定する is 演算子も True を返します。

# このように == 演算子ではオブジェクトの値が同じかどうかを判定するのに対して is 演算子ではオブジェクトが同じかどうかを判定します。

# mutableオブジェクトとimmutableオブジェクトでの is 演算子の結果の違い
# 先ほどはリストのオブジェクトを使って試してみましたが、今度は文字列で同じように試してみます。

# >>> str1 = "Apple"
# >>> str2 = "Apple"
# >>> str1 == str2
# True
# >>> str1 is str2
# True
# >>>
# 文字列のオブジェクトをそれぞれ作成しているにも関わらず == 演算子だけではなく is 演算子も True を返しています。

# オブジェクトには一度作成したあとで変更することができるもの( mutable といいます)と、一度作成すると変更できないもの( immutable )があります。数値や文字列、タプルは変更できないオブジェクトです。リストや辞書は変更できるオブジェクトです。

# なぜリストは同じ値を持つオブジェクトを 2 つ作った時にそれぞれオブジェクトが異なるのに文字列では同じ値を持つオブジェクトを 2 つ作った時に同じオブジェクトになったのかというと、変更できるオブジェクトの場合は値が同じでも必ずオブジェクト毎に異なるオブジェクトとなりますが、変更できないオブジェクトの場合は同じデータ型で同じ値のオブジェクトが既に存在した場合は新しいオブジェクトを作成せずに既にあるオブジェクトを参照する場合があるためです。

# 注意が必要なのは immutable のオブジェクトは必ず別々のオブジェクトが作成されるのに対して、 mutable のオブジェクトは同じ値のオブジェクトを作成した時に同じオブジェクトを参照する場合もあるししない場合もあるということです。必ず同じオブジェクトになるという前提でコードを記述するのはお勧めできません。

# id関数を使ってオブジェクト固有のidを取得する
# 組み込み関数で用意されている id 関数を使うと引数に指定したオブジェクトを表す固有の番号を取得することができます。例えば同じ値を持つリストを 2 つ作成し、それぞれ id 関数を使ってオブジェクトの id を取得してみます。

# >>> list1 = [1, 2, 3]
# >>> list2 = [1, 2, 3]
# >>> id(list1)
# 2621838287560
# >>> id(list2)
# 2621838778312
# >>>
# このようにリストの場合は同じ値を持つオブジェクトを作成しても、それぞれ別々のオブジェクトが割り当てられていることが分かります。

# 今度はリストを作成したあとで、別のリストに代入してみます。

# >>> list1 = [1, 2, 3]
# >>> list2 = list1
# >>> id(list1)
# 2621839912264
# >>> id(list2)
# 2621839912264
# >>>
# 今度は 2 つのリストが同じ id となりました。 2 つのリストは同じオブジェクトを参照していることが確認できます。

# 次に同じ値を持つ 2 つの数値を作成して確認してみます。

# >>> num1 = 10
# >>> num2 = 10
# >>> id(num1)
# 140732009243568
# >>> id(num2)
# 140732009243568
# >>>
# 別々に作成したオブジェクトですが、オブジェクトの id が同じであり同じオブジェクトを参照していることが確認できます。このように数値や文字列などの immutable オブジェクトの場合は既に同じ値を持つオブジェクトが存在した場合は同じオブジェクトを参照する場合があることが id 関数を使っても確認することができました。

# -- --

# is 演算子を使ってオブジェクトが同じかどうか調べる方法と、オブジェクトの値が同じかどうかを調べる == 演算子との違いを解説しました。


