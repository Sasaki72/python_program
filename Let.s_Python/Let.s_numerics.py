# 【数値】

# 数値リテラルを記述する
# 四則演算に関する演算子
# ビット演算に関する演算子
# 演算子の優先順位
# 文字列を数値に変換して数値と演算する
# ブール値(True、False)の使い方


# 【数値リテラルを記述する】
# 数値リテラルを記述する

# Python を使ったプログラムの中で数値リテラルを記述する方法について解説します。数値リテラルというのは数値の定数のことです。

# 数値リテラルを記述する
# Python では数値型として整数、浮動小数点数、複素数の3つが用意されています。

# 整数は小数点がない数値のことです。プログラムの中で記述する場合は整数の値をそのまま記述してください。

# 128
# 0
# -16

# 整数は 10 進数で記述しますが、 2 進数、 8 進数、 16 進数で記述することもできます。 2 進数の場合は 0b1011 のように記述し、 8 進数の場合は 0o624 のように記述し、 16 進数の場合は 0x7F のように記述します。

# 0b1011
# 0o624
# 0x7F

# ※ 整数型の派生型としてブール型があります。ブール型については「ブール値(True、False)の使い方」を参照されてください。

# 浮動小数点数は小数点がある数値のことです。整数と同じくそのまま小数点がある数値を記述してください。

# 34.225
# -7.41

# 浮動小数点では非常に大きな数値や非常に小さな数値について指数表記も利用できます。

# 8.5e+5
# 2.34e-4

# なお 8.5e+5 というのは 8.5×100000=850000 のことです。また 2.34e-4 というのは 2.34×0.0001=0.000234 のことです。

# 複素数は実部＋虚部で表される数値で虚部には j または J を付けて次のように記述します。

# (3.2 + 4j)

# 複素数を実際に使用するケースはまれだと思われるので、実際に必要になるまで複素数のことは気にされないで構いません。

# サンプルプログラム
# 簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample1-1.py という名前で保存します。

# print(18.414)
# print(256)
# print(3.1e+3)

# 数値リテラルを記述する(1)

# その後、次のように実行してください。

# python sample1-1.py

# 数値リテラルを記述する(2)

# print 関数の引数に指定した数値リテラルが画面に出力されました。

# print 関数は Python の組み込み関数の一つです。より詳細な使い方は「print関数の使い方(文字列を出力する)」を参照されてください。

# -- --

# Python を使ったプログラムの中で数値リテラルを記述する方法について解説しました。



# 【四則演算に関する演算子】
# 四則演算に関する演算子

# Python で用意されている数値型の値で利用可能な演算子の中で、加算や減算などを行う四則演算に関する演算子に関して解説します。


# 四則演算に関する演算子
# 四則演算に関する演算子の一覧です。整数、浮動小数点数、複素数で利用可能です。

# x + y    x と y の和
# x - y    x と y の差
# x * y    x と y の積
# x / y    x と y の商
# x // y   x と y の商を切り下げたもの
# x % y    x / y の剰余
# -x       x の符号反転
# +x       x そのまま
# x ** y   x の y 乗
# 例えば加算を行うには次のように行います。

# 15 + 7        # 22
# 3.4 + 2.225   # 5.625
# 7 + 4.5       # 11.5
# -- --

# 簡単なサンプルを作って試してみます。最初に整数に関する演算です。テキストエディタで次のように記述したあと、 sample2-1.py という名前で保存します。

# print("5 + 7 = " + str(5 + 7))
# print("4 * 8 = " + str(4 * 8))
# print("15 / 2 = " + str(15 / 2))
# print("15 // 2 = " + str(15 // 2))
# print("15 % 2 = " + str(15 % 2))

# 四則演算に関する演算子(1)

# その後で、次のように実行してください。

# python sample2-1.py

# 四則演算に関する演算子(2)

# 演算子の // は商の整数部分だけを取得します。丸め方は負の無限大の方向に丸められます。例えば商の結果が 7.56 であれば 7 、 -4.785 であれば -5 となります。

# -- --

# 次に浮動小数点数に関する演算です。テキストエディタで次のように記述したあと、 sample2-2.py という名前で保存します。

# print("5.2 + 7.485 = " + str(5.2 + 7.485))
# print("8.21 * 3.5 = " + str(8.21 * 3.5))
# print("15.78 / 2.4 = " + str(15.78 / 2.4))
# print("15.78 // 2.4 = " + str(15.78 // 2.4))
# print("15.78 % 2.4 = " + str(15.78 % 2.4))
# 四則演算に関する演算子(3)

# その後で、次のように実行してください。

# python sample2-2.py

# 四則演算に関する演算子(4)

# 演算子の // は商の整数部分だけを取得します。ただし浮動小数点数に対する演算の場合は結果は浮動小数点数となります。丸め方は整数の場合と同じく負の無限大の方向に丸められます。例えば商の結果が 7.56 であれば 7.0 、 -4.785 であれば -5.0 となります。

# 異なる数値型での演算
# 整数と整数、浮動小数点数と浮動小数点の演算だけでなく、整数と浮動小数点数との演算も可能です。異なる数値型で演算を行う場合、より制限が少ない数値型に変換されて演算が行われます。制限が少ない順序は 複素数 > 浮動小数点数 > 整数 となっているので、例えば整数と浮動小数点数の演算の場合は浮動小数点数で、浮動小数点数と複素数の場合は複素数として演算が行われます。

# それでは実際に試してみます。テキストエディタで次のように記述したあと、 sample2-3.py という名前で保存します。

# print("5 + 7.485 = " + str(5 + 7.485))
# print("8.21 * 5 = " + str(8.21 * 5))
# print("18 / 4.2 = " + str(18 / 4.2))

# 異なる数値型での演算(1)

# その後で、次のように実行してください。

# python sample2-3.py

# 異なる数値型での演算(2)

# 整数と浮動小数点数の演算は、より制限の少ない浮動小数点数に変換されて行われ、演算の結果も浮動小数点数となります。

# -- --

# Python で用意されている数値型の値で利用可能な演算子の中で、加算や減算などを行う四則演算に関する演算子に関して解説しました。



# 【ビット演算に関する演算子】
# ビット演算に関する演算子

# Python で用意されている数値型の値で利用可能な演算子の中で、ビット演算に関する演算子に関して解説します。

# ビット演算に関する演算子
# ビット演算に関する演算子の一覧です。ビット演算は整数でのみ利用可能です。

# x | y    x と y のビット単位 論理和
# x ^ y    x と y のビット単位 排他的論理和
# x & y    x と y のビット単位 論理積
# x << n   x の n ビット左シフト
# x >> n   x の n ビット右シフト
# ~x       x のビット反転
# ではそれぞれの演算子について確認してみます。

# ビットOR
# ビット OR は演算子の左辺と右辺の同じ位置にあるビットを比較して、少なくともビットのどちらかが 1 の場合に 1 にします。

# x | y

# 例として 10 と 12 のビット OR を取ってみます。

# 10 | 12

# 1010  = 10
# 1100  = 12
# ------------
# 1110  = 14
# 10 と 12 を 2 進数で表示し、ビット単位で比較します。少なくとも 1 つのビットが 1 になっている場合は 1 、 それ以外は 0 となります。結果として 10 | 12 は 14 となります。

# ビットAND
# ビット AND は演算子の左辺と右辺の同じ位置にあるビットを比較して、両方のビットが 1 の場合に 1 にします。

# x & y

# 例として 10 と 12 のビット AND を取ってみます。

# 10 & 12

# 1010  = 10
# 1100  = 12
# ------------
# 1000  = 08
# 10 と 12 を 2 進数で表示し、ビット単位で比較します。両方のビットが 1 になっている場合は 1 、 それ以外は 0 となります。結果として 10 & 12 は 8 となります。

# ビットXOR
# ビット XOR は演算子の左辺と右辺の同じ位置にあるビットを比較して、どちらか 1 つだけ 1 の場合に 1 にします。

# x ^ y

# 例として 10 と 12 のビット XOR を取ってみます。

# 10 ^ 12

# 1010  = 10
# 1100  = 12
# ------------
# 0110  = 06
# 10 と 12 を 2 進数で表示し、ビット単位で比較します。どちらか片方だけのビットが 1 になっている場合は 1 、 それ以外は 0 となります。結果として 10 ^ 12 は 6 となります。

# ビットNOT
# ビット NOT は演算子の右辺の値のビットを反転します。ビットが 1 なら 0 、ビットが 0 なら 1 にします。

# ~x

# 例として 10 のビット NOT を取ってみます。

# ~10

# 1010  = 10
# ------------
# 0101  = 05
# 10 を 2 進数で表示し、ビットが 1 のところは 0 、ビットが 0 のところは 1 となります。結果として ~10 は 5（-11) となります。

# Python においては整数の桁が無制限となっているため、反転を行う限度がありません。その為 Python におけるビット NOT は 2 の補数の計算方法を使って次のように行います。
# ~x = -(x + 1)

# 左シフト
# 左シフトは左辺の値を右辺の値だけ左へシフトします。

# x << n

# 例として 11 を左へ 2 ビットシフトしてみます。

# 11 << 2

# 001011  = 11
# ------------
# 101100  = 44
# 各ビットを指定した数だけ左へシフトします。シフトしたことによって空いた右端には 0 が格納されます。結果として 11 << 2 は 44 となります。

# 左シフトを 1 ビット行うと値は 2 倍になり、 2 ビット行うと 4 倍となります。

# 右シフト
# 右シフトは左辺の値を右辺の値だけ右へシフトします。

# x >> n

# 例として 11 を右へ 1 ビットシフトしてみます。

# 11 >> 1

# 1011  = 11
# ------------
# 0101  = 5
# 各ビットを指定した数だけ右へシフトします。シフトしたことによって空いた左端には 0 が格納されます。結果として 11 >> 1 は 5 となります。

# 右シフトを 1 ビット行うと値は 1/2 倍になり、 2 ビット行うと 1/4 倍となります。

# ビット演算のサンプル
# 簡単なサンプルを作って試してみます。テキストエディタで次のように記述したあと、 sample4-1.py という名前で保存します。

# print("10 | 12 = " + str(10 | 12))
# print("10 & 12 = " + str(10 & 12))
# print("10 ^ 12 = " + str(10 ^ 12))
# print("~10 = " + str(~10))
# print("11 << 2 = " + str(11 << 2))
# print("11 >> 1 = " + str(11 >> 1))

# ビット演算のサンプル(1)

# その後で、次のように実行してください。

# python sample4-1.py

# ビット演算のサンプル(2)

# それぞれのビット演算を行った結果について出力してみました。

# -- --

# Python で用意されている数値型の値で利用可能な演算子の中で、ビット演算に関する演算子に関して解説しました。



# 【演算子の優先順位】
# 演算子の優先順位の一覧
# Python で定義されている演算子の優先順位は次のようになっています。上から順に優先順位が高くなっています。

# 演算子	説明
# (expressions...), [expressions...], {key: value...}, {expressions...}	式結合またはタプル表示、リスト表示、辞書表示、集合表示
# x[index], x[index:index], x(arguments...), x.attribute	添字指定、スライス操作、呼び出し、属性参照
# await x	Await 式
# **	べき乗
# +x, -x, ~x	正数、負数、ビット単位 NOT
# *, @, /, //, %	乗算、行列乗算、除算、切り捨て除算、剰余
# +, -	加算および減算
# <<, >>	シフト演算
# &	ビット単位 AND
# ^	ビット単位 XOR
# |	ビット単位 OR
# in, not in, is, is not, <, <=, >, >=, !=, ==	所属や同一性のテストを含む比較
# not x	ブール演算 NOT
# and	ブール演算 AND
# or	ブール演算 OR
# if -- else	条件式
# lambda	ラムダ式
# 例えば同じ四則演算の演算子であっても、乗算や除算の演算子である * や / は、加算や現在の演算子である + や - よりも優先順がい高いです。また同じ位置にある演算子は優先順位に差はありません。乗算と除算の演算子である * と / は同じ位置にあるので優先順位は同じです。



# 【文字列を数値に変換して数値と演算する】
# 文字列を数値に変換して数値と演算する

# 数値と文字列で演算を行うにはまず文字列を数値に変換する必要があります。ここでは int 関数や float 関数を使って文字列を数値に変換してから数値と文字列を演算する方法について解説します。

# 数値と文字列の演算
# Python では文字列が数値を表す値だったとしても、数値と文字列を直接演算することはできません。例えば対話モードで次のように数値と文字列を加算してみます。

# >>> 10 + "12"
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: unsupported operand type(s) for +: 'int' and 'str'
# >>>
# このように TypeError が表示されます。

# 数値と文字列の演算を行う場合には、文字列をいったん数値に変換する必要があります。文字列を整数に変換する場合は組み込み関数の int 関数を使い、文字列を浮動小数点数に変換する場合は float 関数を使います。

# int 関数および float 関数の詳細な使い方は「int関数/float関数の使い方(文字列を数値に変換する)」を参照されてください。

# 具体的には次のように記述します。

# num = "25"
# print(15 + int(num))

# 浮動小数点数の値の文字列を浮動小数点数として演算する場合は次のように記述します。

# num = "18.325"
# print(4.5 + float(num));

# このように文字列を整数または浮動小数点数に変換することで数値と演算を行うことができます。

# サンプルプログラム
# それでは簡単なサンプルプログラムを作って試してみます。テキストエディタで次のように記述したあと、 sample6-1.py という名前で保存します。

# num1 = "25"
# num2 = "3.155"

# print (18 + int(num1))
# print (4.5 + float(num2))

# 数値と文字列の演算(1)

# その後で、次のように実行してください。

# python sample6-1.py

# 数値と文字列の演算(2)

# 文字列を数値に変換し、その後で数値と演算を行うことができました。

# -- --

# int 関数や float 関数を使って文字列を数値に変換し、文字列と数値を演算する方法について解説しました。



# 【ブール値(True、False)の使い方】
# 【TrueとFalseについて】
# TrueとFalseについて
# ブール値は整数型の派遣型で True と False という 2 つのオブジェクトだけが存在しています。
# if 文の条件式などで真か偽か評価されるときにブール値の True オブジェクトは真と評価され False オブジェクトは偽と評価されます。そこで変数に対して True または False を代入して if 文などの条件式で評価を行う時に使用されたりします。
# >>> flag = True
# >>> if (flag):
# ...     print("Succeeded")
# ... else:
# ...     print("Failed")
# ...
# Succeeded
# >>>
# またブール値は整数型の派遣型であり True は 1 、 False は 0 としても使用することができます。その為、四則演算などを行うことができます。
# >>> True + 8
# 9
# >>> False + 2
# 2
# >>>
# True は 1 、 False は 0 と等価ですが、文字列に変換した場合にはそれぞれ "True" と "False" となります。
# >>> str(True)
# 'True'
# >>> str(False)
# 'False'
# >>>
# ブール値は特に条件式などで利用されることが多いデータ型です。オブジェクトを評価したときに真と偽になる値は色々ありますが、ブール値の True と False は分かりやすい値なので覚えておかれてください。