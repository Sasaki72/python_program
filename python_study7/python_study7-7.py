#【たくさんの円を動かそう】
# これまでは１つの円を描画してきたが、今度は一度にもっとたくさんの円を描画する
# たくさんの円を制御するには、リストを使ってループ処理する
# 
#【円をディレクショナリとリストで管理する】
# たくさんの円を制御するためには、それぞれの円が持つ値を、すべて管理しないといけない
# １つの円を制御するのには、少なくとも４つの変数が必要
# 「x」・・・ X座標を示す
# 「y」・・・ Y座標を示す
# 「dx」・・・Xの移動量を示す
# 「dy」・・・Yの移動量を示す

# もし、こうした変数のまま、３個の円を制御するならば
# 「1つめの円」・・・x、y、dx、dy
# 「2つめの円」・・・x2、y2、dx2、dy2
# 「3つめの円」・・・x3、y3、dx3、dy3
# 
# という変数が必要になる
# もっと増えれば、その分だけ変数が必要となり、とても管理しにくくなる
# そこで２つの工夫をする

# １つ目の工夫
# 【値をひとまとめにするディクショナリ】
# 「１つの円に関するデータは、ひとまとめにする」という考え方
# そのための方法として、Pythonの「ディクショナリ(Dictionary)」という機能を使う
# ディクショナリは「キーと値のペア」を、ひとまとめにして管理する仕組み
# 例えば、次のように使う。ここでは「ball」は任意の変数名です

# ball = {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1}
#このように記述すると 、ballというひとまとまりの中に、「x」「y」「dx」「dy」が保存される
# 
#もしX座標の値を取り出したいなら 
# ball["x"]
# のように記述し、同様にY座標を取り出したいなら
# ball["y"]

# のように記述する。このようにディクショナリは以下の書式で設定する
# 変数名 = { キー名 : 値, キー名 : 値, ・・・}
# こうして記述すると、それぞれのキーに対して
# 変数名["キー名"]
# という書式で参照できる仕組みです
# このようにディクショナリを使うと、関連するデータをひとまとめにしやすくなる。

# ２つ目の工夫
#【リストを使って複数個扱う】
# 「すべての円をひとまとめにする」という考え方
# ディクショナリを使うと３つの円を扱う場合
# 
# ball = {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1}
# ball2 = {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1}
# ball3 = {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1}
# というように書けますが、このように３つの変数で管理するのは、望ましくない
# なぜなら３つの円を描画するときは
# 
# canvas.create_oval(ball["x"] - 20, ball["y"] - 20, ball["x"] + 20, ball["y"] +20, "erd", width = 0)
# canvas.create_oval(ball2["x"] - 20, ball2["y"] - 20, ball2["x"] + 20, ball2["y"] +20, "erd", width = 0)
# canvas.create_oval(ball3["x"] - 20, ball3["y"] - 20, ball3["x"] + 20, ball3["y"] +20, "erd", width = 0)
# と３行、記述しないといけないため。
# 10個の円を扱うなら10行、100個の円を扱うなら100行、記述しないといけない・・・
# この解決策として「リスト」が有効です
# Lesson5-3(P131)で学習した通り、複数の値を「 [] 」で囲んで整理するもの、そうすると次のように記述できる
# 
# balls = [
#     {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1},
#     {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1},
#     {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1}
# ]
# こうすると、例えば、１つ目の円のX座標とY座標は
# balls[0]["x"]
# および、以下のように取得できる
# balls[0]["y"]
# 
# 2つ目の円であれば
# balls[1]["x"]
# および、以下のように取得できる
# balls[1]["y"]
# 
# よって、例えば１つ目の円を描画するには、以下のように記述できる
# canvas.create_oval(balls[0]["x"] - 20, balls[0]["y"] - 20, balls[0]["x"] + 20, balls[0]["y"] + 20, "red", width = 0)
# これでは、先程のball、ball2、ball3の3つの変数を使う場合と、何ら変わりないが、違うのはループ処理できるという点
# もし、３つすべてを描画するには、１つずつ取り出して、これをループすれは短く書ける
# for b in balls:
#   canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, "red", width = 0)
# 
#【たくさんの円をループで動かす】
# 下記は実際に３つの円を動くようにしたプログラムです
# このプログラムでは、ディクショナリで「色」を指定できるようにした
# 描画したい円を次のように定義してる。ここでの「color」は、描画したい色です
# balls = [
#   {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
#   {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
#   {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"}
# ]

# click関数の中では、このballsのすべての要素に対して、forでループ処理することで、すべての円を動かすようにしてる
# for b in balls:
# ・・・それぞれの円に対する操作・・・
# 
# 描画する処理では、
# canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = b["color"], width = 0)
# というように、fillの引数には「b["color"」を指定しているので、ディクショナリの「color」で指定した色で描画される
# 
# 
# coding:utf-8
import tkinter as tk

# 円をリストで用意する
# X座標：Y座標：x方向の移動：y方向の移動：色
balls = [
    {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
    {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
    {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"}
]

def move():
    global balls
    for b in balls:     # 全ての円に対してループする
        # 今の円を消す
        canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = "white", width = 0)
        # X座標を動かす
        b["x"] = b["x"] + b["dx"]
        # Y座標も動かす
        b["y"] = b["y"] + b["dy"]
        # 次の位置に円を描く
        canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = b["color"], width = 0)
        # 端を超えていたら反対向きにする
        if b["x"] >= canvas.winfo_width():
          b["dx"] = -1
        if b["x"] <= 0:
          b["dx"] = +1
        # Y座標についても同様
        if b["y"] >= canvas.winfo_height():
          b["dy"] = -1
        if b["y"] <= 0:
          b["dy"] = +1
    #　再びタイマー
    root.after(10, move)


# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")

# キャンバスを置く
canvas =tk.Canvas(root, width = 600, height = 400, bg = "white")
canvas.place(x = 0, y = 0)

# タイマーを設定する
root.after(10, move) 

root.mainloop()

