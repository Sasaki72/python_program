# 【クラスとオブジェクト】
# 最近のプログラミングで欠かせないのが「クラス」と「オブジェクト」を使った技法
# この技法を使うと、プログラムを部品化して、再利用しやすくなる
# Chapter７では画面で円が動くプログラムを作りながら、クラスとオブジェクトの基本を学ぶ
#【円が動くプログラムを作ります】
#《クリックした場所に円を表示する》
# 最初はクリックした場所に、円が軌跡のように表示されて行くものを作る
# 次に、前に描いた円を消すことで、軌跡ではなくクリックした場所に円が移動するように改良する
#《円が跳ねるようにする》
# 次に、円が自動的に動くプログラムを作る
# そのためには、円が右方向に動くようにする。その次に、その円がウィンドウの端に当たったら、反対方向に動くように改良する
# 最後に、左右だけでなく斜め方向にも動くようにしていく
#《たくさんの円を動かす》
# さらに、この円の数を増やして、同時に動くようにする。そのためには「リスト」を使って円を複数管理する方法をとる
#《プログラムを組み替えて四角形や三角形も描けるようにする》
# 最後にプログラムを書き換えて、円の他に四角形や三角形も描けるようにする
# そのために、Pythonの「クラス」や「オブジェクト」と呼ばれるプログラミング手法を使う


# 【ウィンドウの中に円を描いていこう】
# tkinterでは、「キャンパス(Canvas)」を置いて、そこに必要な図形を描写する
#《円を描いてみよう》
# coding:utf-8
import tkinter as tk
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# Canvasを置く
canvas =tk.Canvas(root, width =600, height =400, bg="white")
canvas.place(x = 0, y = 0)
# 円を描く
canvas.create_oval(300 - 20, 200 - 20, 300 +20, 200 + 20)
root.mainloop()
# 「キャンパスを作る」
# まずはウィンドウを作る、サイズは600x400ピクセルとし、作ったウィンドウはroot変数に代入する
# root = tk.Tk()
# root.geometry("600x400")
# 次にこのウインドウの上に、キャンパスを重ねる。キャンパスは図形や画像を描画する仕組み
# まずは「Canvasメソッド」を実行してキャンパスを作る。今回は作成したキャンパスを「canbas」と言う名前で変数に代入した
# 最後の引数に指定している「bg」は背景色であり、ここでは「white」として白にした
# canvas =tk.Canvas(root, width =600, height =400, bg="white")
# キャンパスを作成したら、placeメソッドを実行してウィンドウの左上に配置する
# canvas.place(x = 0, y = 0)
# ここまでのプログラミングで、ウィンドウの上に、同じサイズのキャンパスが重なった状態になった
#【円を描画する】
# キャンパスのさまざまなメソッドを使うと、図形や画像を描画できる
# 《Canvasに備わる描画のためのメソッド》
# create_arc(x1, y1, x2, y2, オプション)　　　        弧を描く
# create_bitmap(x, y, オプション)                   ビットマップを描く
# create_image(x, y, オプション)                    画像を描く
# create_line(x1, y1, x2, y2, オプション)           直線を描く
# create_oval(x1, y1, x2, y2, オプション)　         楕円または円を描く
# create_polygon(x1, y1, x2, y2,・・・, オプション)　多角形を描く
# create_rectangle(x1, y1, x2, y2, オプション)      四角形を描く
# create_text(x, y, オプション)                     テキストを描く
# 円を描くには「create_oval」のメソッドを使います。このメソッドには最低、４つの引数を指定する
#《MEMO》４つ以上の引数を指定して、塗りや線の色などを指定する事もできる
# 最初の２つのペアが左上の座標、そして、次の２つのペアが右下の座標
# このメソッドを実行すると、その座標に収まるような楕円、もしくは円が描かれる
# canvas.create_oval(300 - 20, 200 - 20, 300 +20, 200 + 20)
# これによって「中心(300,200)、半径20」の円が描かれる
# キャンパスは「wibth = 600、height = 400」のオプションに設定して、幅600ピクセル、高さ400ピクセルにしてるので、丁度これでキャンパスの中心に円が描かれている事になる
#【円の色を変えてみよう】
# create_ovalメソッドやCanvasに備わる描画のためのメソッドは「黒い線」「塗りなし」で描く
# もし色を付けたいときや線幅を変えたいときは、width,outline、fillの各オプションを指定する
# なお、線を描きたくないときはwidthを0に、塗りたくないときはfillをNoneに指定する
# ・width:線の幅
# ・outline:線の色
# ・fill:塗りの色
# 色は「red」「blue」「green」など、基本的な色を文字列として指定できる
# ここでは「線なし(widthを0)」「赤色(fillを"red")」にして、赤い円にしてみる
# 次のように変更すると、線なしで赤く塗られた円が描かれるようになる
# canvas.create_oval(300 - 20, 200 - 20, 300 +20, 200 + 20, fill = "red", width = 0)
# 上記の「, fill = "red", width = 0)」が修正箇所
#【COLUMN】
# 指定できる色の一覧は下記のサイトに載っている
# https://www.colordic.org


# 【クリックした場所に円を動かしてみよう】
# キャンパスをクリックした時に、その場所に円が動くと言う仕組みを作る
# 【クリックされたところに描画する】
# 今回もChapter6-4と同じ「イベント(event)」を使い、処理を記述する
# しかし、今回の方法は前回のボタンの場合と少し違う
#《bindメソッドを使って実行したい関数を結びつける》
# ボタンの場合、「command=」に関数名を記述しボタンがクリックされたときは、ButtonClick関数を実行するために次のようにした
# button1 = tk.Button(root, text = "チェック", font=("Helvetica", 14), command = ButtonClick)
# 「command = ButtonClick)」　← クリックされた時に実行された関数
# それに対してキャンパスの場合は、bindメソッドを使って、「イベント名」と「実行したい関数」とを結びつける
#「bindメソッド」
# canvas.bind(イベント名, 関数名)
# このようにbindメソッドを使うのは、キャンパスではクリック以外にもダブルクリックなど、その他のイベントもあるため
# イベント名は「キーの装飾」「イベント」「種類」をマイナス記号でつなげ、全体を「<」「>」で囲んだ書式で指定する
# イベントの種類の書式
# <キーの装飾 - イベント - 種類>
# 　　　　　　　　　↑　　　  ↑
#           < Button  -  1  >
#       マウスボタン押下    左ボタン
# 「キーの装飾」とは「Shift」「Ctrl」「Ait」など、一緒に押されたキーの状態を示す
# 必要ないときは(これらのキーが押された事を判定する必要がないときは)、省略できる
# 「イベント」とはイベント種別のこと、「種類」とはボタンやキーの種類
# 「クリックされた」というイベントは"<Button-1>"という文字列
# 上記の例は「１番のマウスボタン(=左ボタン)」が押下(=クリック)されたとき」という意味
#【イベントの種別】
# Button または ButtonPress   押下(クリック)された。種類のところで「１」は左ボタン、「２」は右ボタン、「３」は中央ボタンを、それぞれ示す
# ButtonRelease           ボタンが放された。種類のところの指定は上記と同じ   
# Key または KeyPress      キーボードのキーが押下された。種類のところでキーの番号を指定する
# KeyRelease              キーボードのキーが放された。種類のところの指定は上記と同じ
# Enter                   領域内にマウスパットが入ってきた
# Leave                   領域内からマウスポインタが出て行った
# Motion                  領域内でマウスパットが動いた
# 【イベントの関数には座標などの情報が引数をして渡される】
# 例えば、マウスの左ボタンでクリックされたときに「click (今回の記述はclickとした) 」と名前の関数を実行したいなら下記のように記述する
# canvas.bind("<Button-1>", click)
# これでクリックされた時に、click関数が実行される
# 《MEMO》 「click」というのは今回任意でつけた名前である。もちろん関数名は好きなものでOK
# この時、click関数は、引数としてそのイベント発生時の情報が渡される
# def click(event):
# ・・・クリックされた時の処理をここに書く・・・
# 例えば上記のように、「event」という引数として受け取る書式にしておく
# 《MEMO》今回は「event」としてるが、任意なので他の「e」や「evt」や「a」や「abc」など何でもOK
# 例えば「def click(e):」、として定義した場合は、X座標は「e.x」、Y座標は「e.y」として取得できる
# eventには、クリックされた時の情報が渡される。具体的には、
# ・「event」がクリックされた場所のX座標
# ・「event」がクリックされた場所のY座標
# これらの座標のそれぞれを示す。そこでcreate_ovalメソッドを使って、この座標に円を描画すれば、クリックされた場所に円が描画される
# canvas.create_oval(event.x - 20, event.y - 20, event.x + 20, event.y + 20, fill = "red",width = 0)
# これを使って実行するとクリックした場所に次々と円が出てくる
# coding:utf-8
import tkinter as tk
def click(event):
    # クリックされた時そのに描画する
    canvas.create_oval(event.x - 20, event.y - 20, event.x + 20, event.y + 20, fill = "red", width = 0)
# 「event.x」＝クリックされた「x座標」、「event.y」＝クリックされた「y座標」
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width =600, height =400, bg="white")
canvas.place(x = 0, y = 0)
# イベントを設定する
canvas.bind("<Button-1>", click)
# 「, click」＝ クリックされた時にclick関数が実行されるようにする
root.mainloop()
#【クリックされたところに移動する】
# 次は、クリックされたところに円が増えるのではなく、「クリックしたところに円が移動する」ように動作を変えてみる
# そのためには、円を描くときに「元々描かれていた円を消す」ようにする
# 「消す」というのは分かりにくいので、「消えたように見せる」ようにプログラミングを作る
# いくつか考えがあるが、「元々描かれていた場所で、fill = "white", width = 0 を指定して、線のない白い円を描画する」という方法が簡単
# キャンパスの背景が白なので、そうすれば、消えたように見える
# 【描画する円の位置を保存しておく】
# 円を消すためには、「前回、どの位置に円を描画したのか」を保存しておく必要がある
# そので、変数xと変数yに「前回、描画した位置」を保存しておく
# 最初の値はどのような値でもいいが、ここでは仮に、キャンパスの中心となる（300,200）とする
# 円の座標
# x = 300
# y = 200
# click関数ではこの変数xと変数yを使いたいので、グローバル(global)宣言をしている
# global x, y
# click関数では、まずこの座標に「白色」で描画して元の円を消す
# canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
#《MEMO》初回にclick関数が実行されたときは、赤い円はまだ描かれてませんが、xに「300」、yに「200」が代入されているため、この位置に白い円が描画される
# 白いキャンパスに白い円を描いても影響はないので、このままにしている、もしきになるなら「初回は白い円を描画しないようにする」とか「xやyの範囲をキャンパスからはみ出る場所(マイナスの値やキャンパスサイズよりも大きな座標)に指定する」などのやり方でもOK
# そしてクリックされた座標(event.x、event.y)を、変数xと変数yにそれぞれ代入してから、その座標に、赤く塗られた円を描画する
# x = event.x
# y = event.y
# canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", white = 0)
# 変数xと変数yは「いま赤い円を描画した座標」に変わるので、次にclick関数が実行されるときは、この座標に白い円が描画される
# つまり、「前に描いた円が消える」動作になる
# coding:utf-8
import tkinter as tk
# 円の座標
x = 300
y = 200
def click(event):
    global x, y
    # 今の円を消す
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)   # xとyは、前回クリックした座標　# 白で塗りつぶされた円を描く
    x = event.x     # クリックされた座標を保存
    y = event.y     # クリックされた座標を保存
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0)     # 赤で塗りつぶした円を描く
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width =600, height =400, bg="white")
canvas.place(x = 0, y = 0)
# イベントを設定する
canvas.bind("<Button-1>", click)                          # クリックされたときにclick関数を実行する
# 「, click」＝ クリックされた時にclick関数が実行されるようにする
root.mainloop()


#【円を右に動かす】
# Lesson7-4ではクリックしなくても円が勝手に右に動いていくプログラムを作っていく

#【一定時間ごとにズラしていく】
#「円を右に動かす」のは難しいように思えますが、要は結果として、円が右に動いていくように見えればいい
# どのようにするかというと、「少しずつ円のX座標を増やしながら描いたり消したりを繰り返すこと」
# そうすることで、その連続した動作が右に動いていくように見える

#【tkinterのタイマーを使って一定時間ごとに関数を実行する】
# tkinterには「タイマー機能が」あり、一定時間が経過した後に指定した関数を実行できる
# タイマーはtkinterオブジェクトのafterメソッドを呼び出すことで動き出す
# 例えば、
# root = tk.Tk()

# というように変数rootがtkinterオブジェクトを指している場合、タイマーを動かすには以下を記述する
# root.after(時間, 実行したい関数)

# 時間は1000分の1秒単位で指定する
# この単位を「ミリ秒」をいう
# 例えば、「500」と指定した場合は、「0.5秒後に実行する」という意味
# 円が動くようなアニメーションであれば、30 (=0.03秒) 〜10 (=0.01秒)程度の微小な値を指定して、そのつど円を描画する座標を少しずつ変えていくと動いているように見える
#《MEMO》テレビや映画のアニメーションは1秒間に24コマまたは30コマで動いている
# なのでそういったスムーズに動かしたいのであれば、1000÷24≒40程度の値以下に指定するといい、それより大きいと動きがカクカクする


# coding:utf-8
import tkinter as tk
# 円の座標
x = 300
y = 200
def move():
    global x, y             # 増やしていくので右に動く
    # 今の円を消す
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
    # X座標を動かす
    x = x + 1
    # 次の位置に円を描く
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0)
    # 再びタイマー
    root.after(10, move)    # 次も実行されるようにするため再設定する
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width =600, height =400, bg="white")
canvas.place(x = 0, y = 0)
# タイマーを設定する
root.after(10, move)        # 0.01秒後にmove関数が実行されるように設定する
root.mainloop()
# 今回はafterメソッドを使い、0.01秒 (=10ミリ秒)後に、move関数を実行するようにした
root.after(10, move)
# move関数では、いまの場所の円を消しています。これは前のLessonで説明した、クリックで円を動かす時と同じ処理
# いまの円を消す
# canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
# そしてX座標を増やして、その位置に円を描画する
# X座標を動かす
# x = x + 1
# 次の位置に円を描く
# canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0)
# afterメソッドは「1回だけ」有効なので、このままではもうmove関数は呼び出せない
# 従って、もう1度afterメソッドでmove関数を登場し、次も実行されるようにする
# 再びタイマー
# root.after(10, move)
#《COLUMN》
# もっと速く円を動かしたいときは、２つの方法がある
# ①タイマーの感覚を速くする
# １つ目の方法は、afterメソッドに渡す「ミリ秒後」の値を小さくすること
# 今回は「１０」に指定してるが、これを「５」にすれば、move関数が0.005秒に1回実行されるようになるので倍速で動く
# root.after(5, move)
# 注意：ただしこの方法は実行される回数が増えてパソコンの負荷が高まるので、あまり小さい値にすべきではない 
# ②座標の移動量を増やす
# Xの移動量を増やすやり方
# x座標を動かす
# x = x +1
# とあるが
# x = x + 2
# のように２つずつ増やせば、倍速で動くようになる


#【往復して動かせるようにする】
# 今回は円がキャンパスの端に当たったときには、そこで移動が反転して往復運動するように改良していく
#【キャンパスの端に当たったら、移動量を反転する】
# 方法は簡単で、円のX座標とキャンパスの左端・右端のX座標を判定して、もし超えたら反転するように設定すれば良い
# 反転することろの判定は、左端(=X座標が0)と右端(=X座標がキャンパスの幅)の2点で行う
# 移動していくのは円なので、判定する座標には半径も含めた方が良いが、ここでは簡単にするために、「円」の「中心点」で判定する
# つまり、円自体は半径の分だけはみ出てから反転する
#【移動量を変数にする】
# coding:utf-8
import tkinter as tk
# 円の座標と半径
x = 400
y = 300
# 移動量
dx = 1              # 最初は1、つまり右方方向に動かす
def move():
    global x, y, dx
    # 今の円を消す
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
    # X座標を動かす
    x = x + dx      # dxは「１」か「-１」のいずれかです
    # 次の位置に円を描く
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0)
    # 端を超えていたら反対向きにする
    if x >= canvas.winfo_width():
      dx = -1       # 左に移動するようにする
    if x <= 0:
      dx = +1       # 右に移動するようにする
    #　再びタイマー
    root.after(10, move)
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width =600, height =400, bg="white")
canvas.place(x = 0, y = 0)
# タイマーを設定する
root.after(10, move) 
root.mainloop()
# 円が右に移動するプログラムでは、
# x = x + 1
# のようにX座標に「１」を加えていましたが、左に移動させるには、今度は逆にX座標を減らす
# そこで、このプログラムでは「移動量」を変数にして、dxという変数名にした
# 移動量
# dx = 1
# そして、move関数の中では、
# x = x + dx
# としてX座標を変更している。最初は、dxの値が「１」なので、１が足される。つまり、右に進んでいく
#《MEMO》ここでの変数名を「dx」としたが、他の名前でも良い。「dx」の「d」は「delta」の意味として、何かの微小な差を保存する時の変数名によく使う
#【キャンパスの端で移動量を反転する】
# 円がキャンパスの端まで移動したときは、その移動量ー変数dxの値ーを反転させる。反転すべき点は、右端と左端の両方にある
# ①右端の反転
# if x >= canvas.winfo_width():
#    dx = -1
# 右端は、X座標がキャンパス幅を超えたかどうかで調査する。キャンパス幅は、winfo_widthメソッドを実行すると取得できる
# キャンパスの右端を超えたときは、「-1」を設定した。
# そうすることで、円を移動する処理である以下の部分で「−１」が足されていくようになるので、X座標が減っていく(=円が左方向に動く=反転する)ようになる
# x = x + dx 
#《MEMO》このプログラムでは、キャンパス幅が600なので、winfo_widthというメソッドを使わず、「x >= 600」と記述しても同じ
# しかしメソッドを使って取得しておけば、あとでキャンパスの大きさを変更することになったときでも、ifの部分の修正が必要ない
# その理由から、固定値を書くのではなく、この例のようにメソッドを使って実際の値を取得するようにプログラムした方が望ましい
# ②左端の反転 
# 左端のX座標の判定は、次のようになる
# if x <= 0:
#左側はX座標が０なので、「x <= 0」で比較する 
# ここでは、dxを「+1」に設定してるので、今度はxに「+1」が足されていくようになるので、X座標が増えていく(=円が右方向に動いていく=反転する)ようになる
#《MEMO》ここでは、プラスであることを分かりやすくするため、「dx = +1」と記述しましたが、「dx = 1」と記述しても同じである
# ①と②の処理によって、「右端に来たときは移動量が「+1」から「-1」へ、左端に来たときは移動量が「-1」から「+1」へ変わるので、円が左右に往復運動する」動きになる


# 【斜めに動かそう】
# 今度はX座標とY座標の方向にも動くように設定して、円が斜めに動いて見えるプログラムを作る
#【斜めに動かすには】
# X座標方向とY座標方向に同時に動かしていくようにプログラムを作る
# 前回はdxという変数でXの移動量を保持して左右に移動させた
# 同様に、Y座標方向、つまり上下に動かすにはYの移動量としてdyという変数を導入し、この変数dyを円のY座標に加えていく処理をする
# このY座標の処理を前Lessonで作成したプログラムに加えると、X座標方向(左右)とY座標(上下)が同時に動くので、結果として斜め(45度)に動く
# この時も、円がキャンパスの高さを超えた時の処理も記述する
# つまり、上辺(=Y座標が０)と下辺(=Y座標がキャンパスの高さ)の２点判定し、移動を反転させる
#【X座標とY座標を同時に動かす】 
# まずY座標の移動量として、dy変数を導入
# 移動量
# dx = 1
# dy = 1      # yの移動量の最初は１、つまり下方向とする
#そしてmove関数では、Y座標をdyの数だけ増加するようにした
# Y座標も動かす
# y = y +dy
# Y座標はキャンパスの上辺(=Y座標が０)と下辺(=Y座標がキャンパスの高さ)で判定処理する
# その座標で変数dyのプラスとマイナスが逆になるように設定すると、円の動きが反転するようになる
# キャンパスの高さは「winfo_heightメソッド」で取得できる。考え方はLesson7-5でX座標に対して行ったのと同じで、それをY座標に対しても適応するだけ
# Y座標についても同様
# if y >= canvas.winfo_height():      # 下辺を超えた時
#    dy = -1                          # 上方向にする
# if y <= 0:                          # 上辺を超えた時
#    dy = +1                          # 下方向にする
# こうしたY座標の処理を加えることで、X座標方向とY座標方向へ同時に動くようになる
# これで円が斜めに動き、ウィンドウの上下左右の端で反転するので、結果として円が跳ね回るような動きになる
# coding:utf-8
import tkinter as tk
# 円の座標と半径
x = 400
y = 300
# 移動量
dx = 1              
dy = 1
def move():
    global x, y, dx, dy
    # 今の円を消す
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
    # X座標を動かす
    x = x + dx
    # Y座標も動かす
    y = y + dy
    # 次の位置に円を描く
    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0)
    # 端を超えていたら反対向きにする
    if x >= canvas.winfo_width():           # 右辺を越えた時
      dx = -1                               # 左方向へ
    if x <= 0:                              # 左辺を越えた時
      dx = +1                               # 右方向へ
    # Y座標についても同様
    if y >= canvas.winfo_width():           # 下辺を越えた時
      dy = -1                               # 上方向へ
    if y <= 0:                              # 上辺を越えた時
      dy = +1                               # 下方向へ
    #　再びタイマー
    root.after(10, move)
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width = 600, height = 400, bg = "white")
canvas.place(x = 0, y = 0)
# タイマーを設定する
root.after(10, move) 
root.mainloop()


#【たくさんの円を動かそう】
# これまでは１つの円を描画してきたが、今度は一度にもっとたくさんの円を描画する
# たくさんの円を制御するには、リストを使ってループ処理する
#【円をディレクショナリとリストで管理する】
# たくさんの円を制御するためには、それぞれの円が持つ値を、すべて管理しないといけない
# １つの円を制御するのには、少なくとも４つの変数が必要
# 「x」・・・ X座標を示す
# 「y」・・・ Y座標を示す
# 「dx」・・・Xの移動量を示す
# 「dy」・・・Yの移動量を示す
# もし、こうした変数のまま、３個の円を制御するならば
# 「1つめの円」・・・x、y、dx、dy
# 「2つめの円」・・・x2、y2、dx2、dy2
# 「3つめの円」・・・x3、y3、dx3、dy3
# という変数が必要になる
# もっと増えれば、その分だけ変数が必要となり、とても管理しにくくなる
# そこで２つの工夫をする
# １つ目の工夫
# 【値をひとまとめにするディクショナリ】
# 「１つの円に関するデータは、ひとまとめにする」という考え方
# そのための方法として、Pythonの「ディクショナリ(Dictionary)」という機能を使う
# ディクショナリは「キーと値のペア」を、ひとまとめにして管理する仕組み
# 例えば、次のように使う。ここでは「ball」は任意の変数名です
# ball = {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1}
#このように記述すると 、ballというひとまとまりの中に、「x」「y」「dx」「dy」が保存される
#もしX座標の値を取り出したいなら 
# ball["x"]
# のように記述し、同様にY座標を取り出したいなら
# ball["y"]
# のように記述する。このようにディクショナリは以下の書式で設定する
# 変数名 = { キー名 : 値, キー名 : 値, ・・・}
# こうして記述すると、それぞれのキーに対して
# 変数名["キー名"]
# という書式で参照できる仕組みです
# このようにディクショナリを使うと、関連するデータをひとまとめにしやすくなる。
# ２つ目の工夫
#【リストを使って複数個扱う】
# 「すべての円をひとまとめにする」という考え方
# ディクショナリを使うと３つの円を扱う場合
# ball = {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1}
# ball2 = {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1}
# ball3 = {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1}
# というように書けますが、このように３つの変数で管理するのは、望ましくない
# なぜなら３つの円を描画するときは
# canvas.create_oval(ball["x"] - 20, ball["y"] - 20, ball["x"] + 20, ball["y"] +20, "erd", width = 0)
# canvas.create_oval(ball2["x"] - 20, ball2["y"] - 20, ball2["x"] + 20, ball2["y"] +20, "erd", width = 0)
# canvas.create_oval(ball3["x"] - 20, ball3["y"] - 20, ball3["x"] + 20, ball3["y"] +20, "erd", width = 0)
# と３行、記述しないといけないため。
# 10個の円を扱うなら10行、100個の円を扱うなら100行、記述しないといけない・・・
# この解決策として「リスト」が有効です
# Lesson5-3(P131)で学習した通り、複数の値を「 [] 」で囲んで整理するもの、そうすると次のように記述できる
# balls = [
#     {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1},
#     {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1},
#     {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1}
# ]
# こうすると、例えば、１つ目の円のX座標とY座標は
# balls[0]["x"]
# および、以下のように取得できる
# balls[0]["y"]
# 2つ目の円であれば
# balls[1]["x"]
# および、以下のように取得できる
# balls[1]["y"]
# よって、例えば１つ目の円を描画するには、以下のように記述できる
# canvas.create_oval(balls[0]["x"] - 20, balls[0]["y"] - 20, balls[0]["x"] + 20, balls[0]["y"] + 20, "red", width = 0)
# これでは、先程のball、ball2、ball3の3つの変数を使う場合と、何ら変わりないが、違うのはループ処理できるという点
# もし、３つすべてを描画するには、１つずつ取り出して、これをループすれは短く書ける
# for b in balls:
#   canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, "red", width = 0)
#【たくさんの円をループで動かす】
# 下記は実際に３つの円を動くようにしたプログラムです
# このプログラムでは、ディクショナリで「色」を指定できるようにした
# 描画したい円を次のように定義してる。ここでの「color」は、描画したい色です
# balls = [
#   {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
#   {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
#   {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"}
# ]
# click関数の中では、このballsのすべての要素に対して、forでループ処理することで、すべての円を動かすようにしてる
# for b in balls:
# ・・・それぞれの円に対する操作・・・
# 描画する処理では、
# canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = b["color"], width = 0)
# というように、fillの引数には「b["color"」を指定しているので、ディクショナリの「color」で指定した色で描画される
# coding:utf-8
import tkinter as tk
# 円をリストで用意する
# X座標：Y座標：x方向の移動：y方向の移動：色
balls = [
    {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
    {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
    {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"}
]
def move():
    global balls
    for b in balls:     # 全ての円に対してループする
        # 今の円を消す
        canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = "white", width = 0)
        # X座標を動かす
        b["x"] = b["x"] + b["dx"]
        # Y座標も動かす
        b["y"] = b["y"] + b["dy"]
        # 次の位置に円を描く
        canvas.create_oval(b["x"] - 20, b["y"] - 20, b["x"] + 20, b["y"] + 20, fill = b["color"], width = 0)
        # 端を超えていたら反対向きにする
        if b["x"] >= canvas.winfo_width():
          b["dx"] = -1
        if b["x"] <= 0:
          b["dx"] = +1
        # Y座標についても同様
        if b["y"] >= canvas.winfo_height():
          b["dy"] = -1
        if b["y"] <= 0:
          b["dy"] = +1
    #　再びタイマー
    root.after(10, move)
# ウィンドウを描く
root = tk.Tk()
root.geometry("600x400")
# キャンバスを置く
canvas =tk.Canvas(root, width = 600, height = 400, bg = "white")
canvas.place(x = 0, y = 0)
# タイマーを設定する
root.after(10, move) 
root.mainloop()
# 【もっとたくさんの円を動かすのも簡単】
# 上記では３つの円ですが例えば５つだと
# balls = [
#   {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
#   {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
#   {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"},
#   {"x" : 50, "y" : 400, "dx" : -1, "dy" : 1, "color" : "purple"},
#   {"x" : 400, "y" : 100, "dx" : 1, "dy" : 1, "color" : "yellow"},
#]
# データの定義を５つにすれば、５つの円が表示される
# この変更に伴って、「move関数」など他の部分を変更する必要はない
# リストでデータの定義を変更するだけでいい
# このようにデータを変更するだけで、扱う円の個数を変更できるのは、ディクショナリとリストを使ったプログラミングの大きな利点である


#【プログラミングをブロック化して１つの機能を与える】
# 前のLessonでは、ディクショナリとリストを使って、複数の円を描画するプログラムを作りました。
# これには実は、別解がある。それはクラスとオブジェクトを使う方法です。
# 【プログラムをブロック化して１つの機能を与える】
# 前のLessonで作った、「ディクショナリ」と「リスト」を使って、円の座標や移動方向、描画色などのテータを管理して、それを１つずつループ処理して描画する方法は、昔からある古典的な手法である
# それに対して最近は、プログラムを部品化(コンポーネント化)して、様々な操作を実現する方法が、よく採らる
# 今回の例でいうと、１つ１つの「円」を部品として扱う
# 内部で自分の状態 (今回の例で言えば、「座標や移動方向」「描画色」)を保持している
# 部品は、外部から様々な「命令」を受け付けるように作っておく
# 例えば、「動かす」とか「消す」といった命令を受け付けられるようにしておく
# プログラムは、そうした命令を実行することで、部品をコントロールしていく
# ここで言う部品こそが「オブジェクト」で、その命令は「メソッド」に相当する
# 「これまで作ってきたプログラム」と「オブジェクトを使ったプログラム」の考え方の違いを次の図7-8-1に示した
# 大きな違いは「データをどこで管理するか」という点にある
# これまで作ってきたプロブラムでは、データがディクショナリやリストでひとまとまりにして管理されていたのに対し、オブジェクトを使ったプログラムの場合は、それぞれのオブジェクトがデータを持っており、それに対して命令を出すようにプログラミングしてる
# 図7-8-1 オブジェクト側にプログラムがあり、外部からはそれに対して命令を与えるだけ
# 《これまでのプログラム》
# ・データ
#  balls = [
#    {"x" : 400, "y" : 300, "dx" : 1, "dy" : 1, "color" : "red"},
#    {"x" : 200, "y" : 100, "dx" : -1, "dy" : 1, "color" : "green"},
#    {"x" : 100, "y" : 200, "dx" : 1, "dy" : -1, "color" : "blue"}
#]
#                              ｜ 
#                              ｜ 
#                              ｜
#              　　　　　　　　　 ｜  (データをひとつずつ読んで処理していく)
# ・プログラム                　　|
#  for b in balls:             ｜
#    今の円を消す                ⬇️
#    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "white", width = 0)
#    X座標を動かす
#    x = x + dx
#    Y座標も動かす
#    y = y + dy
#    次の位置に円を描く
#    canvas.create_oval(x - 20, y - 20, x + 20, y + 20, fill = "red", width = 0) 
# 《オブジェクトを使ったプログラム》
#   for b balls:                               ↗️ 動かすプログラム(関数・メソッド) Ballオブジェクト
#     #動かす   ーーーーーーーーーーーーーーーーーーー➡　動かすプログラム(関数・メソッド) Ballオブジェクト
#     b.動かす()                 ⬆️          　　↘️ 動かすプログラム(関数・メソッド) Ballオブジェクト
#               プログラムでは「動かす」と命令するだけ                ⬆️
#                                                        　　　　⬆️
#                     canvas.create_ovalメソッドの実行など、消したり描画したりするプログラムは、オブジェクト側に備わるようにする
# 【オブジェクトはクラスから作る】 
# 実はオブジェクトはプログラマが記述するのもではない。プログラマが記述するのは、オブジェクトの基となる「クラス(class)」と呼ばれるものである
# オブジェクトを使いたい場合、プログラマは、クラスというものをプログラムとして記述しておく
# このようにしておいて、オブジェクトを使いたい時は、Pythonの特定の文法(後で説明)を使って、クラスからオブジェクトを作り出します
# こうして作ったオブジェクトのことを「インスタンス(instance)」という
# そして、クラスからオブジェクトを作り出す操作のことを、「実体化する」とか「インスタンスを作る」と言う
# 図7-8-2にも示したように、クラスとオブジェクトは、１対多数の関係です
# クラスを作成しておけば、そのクラスを基としたオブジェクトを、いくつでも作れる
# 図7-8-2
#              インスタンスを作る操作                 
#          　　　　　 　　⬇️　　　　↗️  オブジェクト
#        クラス ーーーーーーーーーー▶️　 オブジェクト
#          ⬆️                   ↘️ 　オブジェクト
#   プログラマが書くのがこれ
# 【クラスでデータを管理する】
# クラスとオブジェクトの話はとても難しいので、順を追って説明する
# 最終的には、円を動かすオブジェクトを作っていくので、ひとまず「動かす」と言うことは忘れて、ここでは円の座標や移動量、色を管理するデータについて考える
# 《クラスを作る》
# 前Lessonでディクショナリとリストを使ったプログラムの例から分かるように、１つの円は以下５つのデータを持っている
# 「x座標、y座標、xの移動量、yの移動量、色」
#そこでまずは、この5種類のデータをオブジェクト内部で管理できるようにし、そのためのクラスを記述する。 
# クラス名は、何でも構いませんが、ここでは仮に「ball」という名前にする。Pythonでクラスを作る場合は、次のような書式で記述する
# class クラス名：
#     クラスの定義内容
# ここでは、次のようにBallクラスを作る
# class Ball:
#   def_init_(self, x, y, dx,dy, color):
#   self.x = x
#   self.y = y
#   self.dx = dx
#   self.dy = dy
#   self.color = color
# ここで定義した「_init_」と言うのは、最初にオブジェクトを作る時に呼び出される特殊な関数で「コンストラクタ(constructor)」と呼ばれる
# コンストラクタは、オブジェクトの状態を、最初の状態にするときの処理をするのに使う
# 《クラスからオブジェクトを作る》
# このようにBallクラスを作った時、このクラスからオブジェクト(Ballオブジェクト)を作るには、次のように記述する。
# このようにすると、Ballオブジェクトができ、変数bに代入される(変数bは任意の名称であり、どのような変数でも構わない)
# b = Ball(400, 300, 1, 1, "red")
# このとき内部では、コンストラクタ(クラス内に記述した(init)と言う名前の関数)が実行され一連の処理が実行される
# この結果、Ballオブジェクトの中には「x」「y」「dx」「dy」「color」という名前の変数ができ、そのに引数に渡された値が代入される
# このようにオブジェクトの内部にある変数を「インスタンス変数」と呼ぶ
# 《自身を示すself》
# さて「_init_」について、もう少し詳しく見る。defで定義されているように、これは関数ですが、普通の関数とクラスの内部で定義した関数とでは、大きな違いが１つある
# それは、「１つめの引数は、「オブジェクトを指す特別な変数である」」と言う点
# いま提示した例では、_init_関数を以下のように定義した
# def_init_(self, x, y, dx, dy, color):
# この先頭の「「self」は、「オブジェクト」を指し示す」と言う約束になっている
# 以降、このクラスには他のいくつかのメソッドを作っていくことになるが、「先頭の引数は、いつも操作対象のオブジェクトが渡される」という点は共通です
# このようにして渡されたselfに対して「self.x」や「self.y」のように、「.」でつなげて任意の変数名を記述すると、それを変数として使える
# このようなオブジェクトの内部の変数のことを「インスタンス変数」と言う
# 《MEMO》関数の１つめの引数は、慣例的にselfと言う名前が使われますが、self以外の名前でも構わない。たとえば、「def_init_(s, x, y, dx, dy, color):」のように定義しても構わない
# この場合、インスタンス変数を参照するための書式は、「s.x」や「s.y」のようになる
# 【メソッドを実装する】
# このように「_init_」関数を使って、「self変数名」に値を代入することで、そのオブジェクトに任意のデータを保存して管理できるようになる
# 次に、このオブジェクトに、命令を与えることができる「メソッド(method)」を作っていく
# 最終的には「円を動かす」というメソッドを実装することになるが、最初からは難しいので、簡単なtestと言うメソッドを実装していく
# メソッドはクラス内部で定義された関数に過ぎない
# たとえば、次のようにtestメソッドを記述する
# class Ball:
#     def_init_(self, x, y, dx, dy, color):
#         self.x = x
#         self.y = y
#         self.dx = dx
#         self.dy = dy
#         self.color = color
#     def test(self)            # testメソッド
#         print(self.x)         # testメソッド
#         print(self.y)         # testメソッド
# ここで実装したtestメソッドは、
# def test(self)
#     print(self.x)
#     print(self.y)
# のようにした。これは、「self.x」と「self.y」を表示するだけのもの
# ここで、
# b = Ball(400, 300, 1, 1, "red")
# として、Ballオブジェクトを作ったとする
# この場合「self.x」は「400」、「self.y」は「300」になっている
# なので、以下を実行すると画面には「400」「300」と表示される
# b.test()
# 図7-8-4(P218)
# 【円を動かすメソッドを作る】
# ここまでの説明を踏まえて、「円を動かす」と言うプログラムをクラスとオブジェクトを使って実装してみる
# まずは「１つの円を動かす」というプログラムを示す。
# 動かす処理は、Ballクラスのmoveメソッドに記述
# 《円をオブジェクトとして作り、動かす》
# プログラムでは、まず、次のように、Ballオブジェクトを作っている。
# ここでは変数bに代入した
# b = Ball(400, 300, 1, ,1 "red")
# 定期的にタイマーで起動するloop関数を次のように定義した(タイマー：P196参照)
# def loop():
# 動かす
# b.move(canvas)
# もう一回
# root.after(10, loop)
# 0.01秒(10ミリ秒)後に、このloop関数が実行されるように、次のようにしてタイマー登録している
# root.after(10, move)
# 【動かす操作】
# 上記のroop関数では
# b.move(canvas)
# と言うように、変数bが指しているBallオブジェクトのmoveメソッドを実行している
# moveメソッドは、次のように定義している
# def move(self, canvas)
# 最初の引数は、このオブジェクトを示すことは説明済み。
# ２番目の引数は、実行されるときに渡した値(ここではb.move(canvas)としてmoveメソッドを実行しているので、このときに渡したcanvas)です
# moveメソッドではまず、円を白色で描画することで消している。
# 対象の座標は、「self.x」と「self.y」です
# canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
# 描画が済んだら、X座標とY座標を次の位置に移動する
# X座標、Y座標を動かす
# self.x = self.x + self.dx
# self.y = self.y + self.dy
# この処理の後、端に当たった時は移動方向を反転させると言うプログラムが続くが、ここでの説明は割愛する
# 【オブジェクトに対して命令を出すことで動かす】
# プログラムは、少し難しいのですが、注目したいことは、
# b.move()
# のように、オブジェクトを代入した変数に対して、moveと言うメソッドを実行するだけで動かしていると言う点です
# moveメソッドで「どんな処理を実行するのか」は、オブジェクト(の基となるクラス)に書かれており、「オブジェクトを使っている側」からは、完全なブラックボックスです(図7-8-5：P220)
# 言い換えると、このBallと言うオブジェクトを「使っている側」は、「moveメソッドを実行すると円が動く」と言う事実だけを知っており、「どうやって動かしているのか」と言う「動かし方」は知りません
# 実際の動かし方はオブジェクトの内部に隠れるため、全体のプログラムがスッキリし、見やすくなる
# coding:utf-8
import tkinter as tk
class Ball:                                     # Ballクラスの定義
    def __init__(self, x, y, dx, dy, color):
        self.x = x
        self.y = y
        self.dx = dx
        self.dy = dy
        self.color = color
    def move(self, canvas):                     # 円を動かすためのメソッド
    # 今の円を消す
        canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
        # X座標、Y座標をを動かす
        self.x = self.x + self.dx
        self.y = self.y + self.dy
        # 次の位置に円を描く
        canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)
        # 端を超えていたら反対向きにする
        if self.x >= canvas.winfo_width():           
          self.dx = -1                               
        if self.x <= 0:                              
          self.dx = +1                               
        if self.y >= canvas.winfo_height():          
          self.dy = -1                               
        if self.y <= 0:                              
          self.dy = +1                               
# 円をひとつ作る
b = Ball(400, 300, 1, 1, "red")                  # Ballオブジェクトを作る
def loop():
  # 動かす
  b.move(canvas)                                 # 「動かす」と命令するだけ
  # もう一回
  root.after(10,loop)
# ウィンドウを描く
root = tk.Tk()
root.geometry("800x600")
# キャンバスを置く
canvas =tk.Canvas(root, width = 800, height = 600, bg = "white")
canvas.place(x = 0, y = 0)
# タイマーをセット
root.after(10, loop) 
root.mainloop()
# 【たくさんの円を動かす】
# 上記では、１つの円しか動かしていないが、これを複数にするのは、とても簡単
# リストとしてBallオブジェクトを用意する
# balls = [
#     Ball(400, 300, 1, 1, "red"),
#     Ball(200, 100, -1, 1, "green"),    ２つ加えた
#     Ball(100, 200, 1, -1, "blue")      ２つ加えた
# ]
# 用意したら、これらのリストをforでループして処理するため、円を動かすloop関数を次のように修正する
# def loop():
#     #動かす
#     for b in balls:           ballsから１つずつ取り出す
#         b.move(canvas)        「動かせと命令する」
#     #もう一回 
#       root.after(10, loop)
# このようにオブジェクトをリストとして構成すれば、いくつでも好きなだけ円を描ける
# 修正が必要なのはデータのところだけで、クラスなどのプログラムを変更する必要はない


#【円だけでなく、四角、三角を混ぜて見よう】
# クラスやオブジェクトのメリットは、作った処理の一部だけを変更しやすい点
# ここでは、その性質を利用して、「四角」と「三角」を混ぜて描画する
# 【機能の違いは描画する所だけ】
# これまで「円」を動かすプログラムでしたが、「四角」と「三角」を混ぜて動かしていく
# 四角と三角の違いは、「描画する形状」だけで、X座標やY座標は増減したり、キャンパスの端に達した時に向きを変えたりする処理はまったく同じ
# なので、描画する所だけを切り替えれば、同じプログラムで実現できる
# 四角形を扱うクラスをRectangle、三角形を扱うクラスをTriangleとして、これから作っていくと、その違いは牡蠣の図になる
# 図7-9-1
# 『円、四角形、三角形の処理の違い 』
#  【Ballクラス】            【Rectangleクラス】              【Triangleクラス】
#  《moveメソッド》           《moveメソッド》                《moveメソッド》
#  「円を消す」               「四角形を消す」                 「三角形を消す」
#   動かす                    動かす                         動かす      
#  「円を描く」                「四角形を描く」                「三角形を描く」
#   端で反対向きにする          端で反対向きにする               端で反対向きにする
# 【図形を消す処理と描く処理を別のメソッドにする】
# クラスには、メソッド単位で処理を変更する機能がある
# この機能は「オーバーライド(override)」と呼ばれ、既存のクラスを改良して、別のクラスを作る基本となる
# 繰り返すが、この機能が使えるのは「メソッド単位」。上記の図7-9-1に示したように違うところは「消す」と「描く」ところです、ここを差し替えるには、それぞれ別のメソッドとして実装する必要がある
# そこでこれまで作ったBallクラスのmoveメソッドを図7-9-2のように変更する
# def move(self, canvas):                          ーーー｜      
#     # 今の円を消す                                      ｜
#     self.erase(canvas)                                ｜
#     # X座標、Y座標をを動かす                            　｜
#     self.x = self.x + self.dx                         ｜
#     self.y = self.y + self.dy                         ｜
#     # 次の位置に円を描く                                 ｜
#     self.draw(canvas)                                 ｜      このmoveメソッドの処理は
#     # 端を超えていたら反対向きにする                       ｜      「円」「四角形」「三角形」の
#     if (self.x >= canvas.winfo_width()):              ｜       どれでも同じ
#         self.dx = -1                                  ｜
#     if (self.x <= 0:)                                 ｜
#         self.dx = +1                                  ｜
#     if (self.y >= canvas.winfo_height()):             ｜
#         self.dy = -1                                  ｜
#     if (self.y <= 0:)                                 ｜
#         self.dy = +1                             ーーー｜
# def erase(self, canvas):     # 円を消す処理
#     canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
# def draw(self, canvas):      # 円を描く処理
#       canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)
# ここでは、消す処理を「eraseメソッド」、描画する処理を「drawメソッド」に分離した
# 【継承して四角形の描画クラスを作る】
# このようにBallクラスを改良しておくと、このクラスを基に、四角形を描画するRectangeクラスを作るのは簡単
# 既存のクラスを基に、新しいクラスを作ることを「継承」と言う
# 継承するクラスの定義
# class新しいクラス名(基のクラス名)：
# とすればよく、同名で同じ動作をするメソッドの記載は省略できる
# そこで、Ballクラスを継承させ、四角形を描画するRectangeクラスを作ると、次のようになる
# class Rectangle(Ball):
#     def erase(self, canvas):  # 四角形を消す
#         canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
#     def draw(self, canvas):   # 四角形を描く
#         canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)
#《MEMO》RectangeはBallクラスを継承しているため、この定義よりも前にBallクラスが定義されていなければならない。すなわちBallクラスの定義(「class Ball」)よりも後ろで、Rectangeクラスを定義しないとエラーになるLesson7-9-1を参照
# 四角形を描画するには、「create_rectangleメソッド」を使う(P186：表7-2-1参照) 
# ここに示したように、このRectangeクラスでは、処理が異なるeraseメソッドとdrawメソッドだけを作り、他は省略してる
# つまり、moveメソッドはBallクラスに実装されたものと同じものが使われる
# これは図7-9-3のように、「Ballクラスの一部のメソッドが上書きされている」を考えると分かりやすい。クラスでは、「オーバーライト」という言葉が出てきますが、このような「処理は上書き」こそが、オーバーライドの実体です
# 図7-9-3 「オーバーライト」
#     【Rectangeクラス】　　　　　　　    【Ballクラス】
#     《moveメソッド》                  《moveメソッド》
#      そのまま  ⬅️ moveメソッドは書いていなくても、基のBallクラスのものが存在する
#                           継承
#     《eraseメソッド》   ⬅️＝＝＝＝＝    《eraseメソッド》
#      四角形を消す ⬅️ーーーーーーーーーーー ×円を消す×
#                         上書き
#     《drawメソッド》                  《drawメソッド》
#      四角形を描く ⬅️ーーーーーーーーーーー ×円を描く×
#                         上書き
# 《四角形を描画する》
# 作成したRectangeクラスを使って四角形を描画する場合、その処理は、次のように記述する
# b = Rectangle(400, 300, 1, 1, "red")
# def loop():
#   動かす
#   b.move(canvas)
#   もう一回
#   root.after(10, loop)
# 円を扱ってきたBallクラスとの違いは
# b = Rectangle(400, 300, 1, 1, "red")
# の1行だけで、「BallクラスではなくRectangleクラスを使うようにする」ことだけ
# 【継承して三角形の描画クラスを作る】
# 同様にして三角形を描画する、Triangleクラスを作る
# 三角形を描画するには、「create_ploygonメソッド」を使う。create_ploygonメソッドは多角形を描画する機能を持つ。
# ３点の座標を指定することで、三角形を描画できる
# 先の四角形と同様に、eraseメソッドとdrawメソッドをオーバーライトすればよく、次のようにして作れる
# class Triangle(Ball):
#     def erase(self, canvas):    # 三角形を消す
#         canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
#     def draw(self, canvas):     # 三角形を描く
#         canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)
# 【三角形を描画する】
# このTriangleクラスを使って三角形を描画する場合は、次のようになる
# b = Triangle(400, 300, 1, 1, "erd")
# def loop():
#   動かす
#   b.move(canvas)
#   もう一回
#   root.after(10, loop)
# 違いは以下の1桁だけ
# b = Triangle(400, 300, 1, 1, "red")
#【混ぜて描く】
# ここまで「円(Ball)」「四角形(Rectangle)」「三角形(Triangle)」の３つのクラスを使い、それぞれ描画する方法を説明してきた
# これらを混ぜて描画するには、どうすればいいか？
# このプログラムではまず、次のようにして一緒に「円」「四角形」「三角形」を作り。それをリストとして構成する
# balls =[
#     Ball(400, 300, 1, 1, "red"),
#     Rectangle(200, 100, -1, 1, "green"),
#     Triangle(100, 200, 1, -1, "blue")
# ]
# そしてこのballs変数をループ処理することで描画していく
# for b in balls:
#     b.move(canvas)
# ここでのポイントとなるのが、どのクラスもBallクラスから継承していて、すべて「moveメソッド」を持っているという点
# このループで実行しているのは、そのオブジェクトの「moveメソッド」です。それが「円(Ballオブジェクト)」「四角形(Rectangleオブジェクト)」「三角形(Triangleオブジェクト)」のどれかであるかは関係ない
# どのオブジェクトかに関係なく、ただ「moveメソッドさえあれば、同じようにループ処理ができる」のである
# coding:utf-8
import tkinter as tk
class Ball:       #円を描くクラスーーーーーーーーーーーーーーーーーーーーーーーー
    def __init__(self, x, y, dx, dy, color):                         #｜
        self.x = x                                                   #｜
        self.y = y                                                   #｜
        self.dx = dx                                                 #｜
        self.dy = dy                                                 #｜  
        self.color = color                                           #｜
#                                                                    #｜
    def move(self, canvas):                                          #｜
        #いまの円を消す                                           　　  #｜ 
        self.erase(canvas)                                           #｜
        #X座標、Y座標を動かす                                           #｜ 
        self.x = self.x + self.dx                            # オーバーライトしてないから、   
        self.y = self.y + self.dy                            # この２つのメソッドはRectangleでも   
        #次の位置に円を描画する                              　  # Triangleでも同じものが使われる
        self.draw(canvas)                                            #｜
        #端を超えていたら反対向きにする                                   #｜   
        if (self.x >= canvas.winfo_width()):                         #｜
            self.dx = -1                                             #｜ 
        if (self.x <= 0):                                            #｜
            self.dx = 1                                              #｜
        if (self.y >= canvas.winfo_height()):                        #｜
            self.dy = -1                                             #｜ 
        if (self.y <= 0):                                            #｜
            self.dy = 1  #ーーーーーーーーーーーーーーーーーーーーーーーーーーー

    def erase(self, canvas):
        canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)

    def draw(self, canvas):
        canvas.create_oval(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)

class Rectangle(Ball):      # 四角形を描くクラス
    def erase(self, canvas):
        canvas.create_rectangle(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = "white", width = 0)
    def draw(self, canvas):
        canvas.create_rectangle(self.x - 20, self.y - 20, self.x + 20, self.y + 20, fill = self.color, width = 0)

class Triangle(Ball):       # 三角形を描くクラス
    def erase(self, canvas):
        canvas.create_polygon(self.x, self.y - 20, self.x + 20, self.y + 20, self.x - 20, self.y + 20, fill = "white", width = 0)
    def draw(self, canvas):
        canvas.create_polygon(self.x, self.y - 20, self.x + 20, self.y + 20, self.x - 20, self.y + 20, fill = self.color, width = 0)

# 円、四角形、三角形をまとめて用意する
balls =[
    Ball(400, 300, 1, 1, "red"),
    Rectangle(200, 100, -1, 1, "green"),
    Triangle(100, 200, 1, -1, "blue")
]
def loop():
    #動かす
    for b in balls:
        b.move(canvas)
    #もう1回
    root.after(10, loop)

# ウィンドウを描く
root = tk.Tk()
root.geometry("800x600")

# Canvasを置く
canvas =tk.Canvas(root, width = 800, height = 600, bg = "#fff")
canvas.place(x = 0, y = 0)

#タイマーをセット
root.after(10, loop)

root.mainloop()


# 【プログラミング】に慣れたら立ち戻る
# クラスとオブジェクトは、難しい概念、身につけて活用するまでには時間がかかる 
# 焦らずじっくり進める
# クラスとオブジェクトはプログラミングの考え方や設計の問題も含むので最初はピンと来ないかも
# 最初のうちはクラスとオブジェクトを使わず、じばらくプロブラミングを進め、改めてクラスとオブジェクトを学ぶと、
# 「こう言う時にクラスとオブジェクトが使えそうだな」という、使い場所が見えてくる
